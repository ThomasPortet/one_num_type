pred translate_prf term -> term, term.
func main_translate_prf term -> term, term.
pred thm_table -> term, term, term.
pred nat_thm_table -> term, term, term.

func add_map term -> term.

add_map {{lp:E = IZR lp:F}} 
(prod `lr` {{list R}} lr\ (prod `lz` {{list Z}} lz\ {{lp:lr= map IZR lp:lz -> @MappR 0 lp:E lp:lr = IZR (@MappZ 0 lp:F lp:lz) }} )).

func hyps_to_list_proof int, term -> term.

hyps_to_list_proof 0 ({{lp:_E = IZR lp:_F}} as T) R :- !,
add_map T R.

hyps_to_list_proof N ((prod _X _Tx x\ prod _Y _Ty y\ prod _H {{lp:x = IZR lp:y}} h\ R) as T)
{{ proj1 (mapp_step' lp:N1Nat lp:F lp:G) (fun x y (eqxy : x = IZR y) => 
lp:RP (lp:F x) (lp:G y) (lp:T x y eqxy)) }}
  :- !,
  N1 is N - 1,
  int_to_nat N1 N1Nat,
  hyps_to_list_proof N1 R RP.

func rnat_prf term, term, term, term -> term. 
rnat_prf A A1 PRFA F Nat_prf :-
  std.do! [
  coq.typecheck Hole {{Rnat lp:A}} ok,
    coq.ltac.collect-goals Hole [G] [],
    if (coq.ltac.open (coq.ltac.call-ltac1 "solve_Rnat") G [])
       (Nat_prf = Hole)
       (Test = {{(0 <=? lp:A1)%Z}},
        coq.reduction.vm.norm Test _ Tv,
        if (Tv = {{false}})
          ( coq.reduction.vm.norm A1 _ V1,
            coq.term->string {{IZR lp:V1}} V1R,
            Diagnostic is
              {coq.term->string F} ^ " has a negative input "
              ^ V1R,
           coq.error Diagnostic)
          (GPRF = {{private.compute_Rnat lp:A lp:A1 lp:PRFA eq_refl}},
           Nat_prf = GPRF)
        )].


func meta_list_to_list (list term) -> term.
meta_list_to_list nil {{nil}}.
meta_list_to_list [A|Tl] {{lp:A::lp:R}} :- meta_list_to_list Tl R.
meta_list_to_list uvar _ :- coq.error "invalid input meta_list_to_list called with flexible argument".

func meta_list_to_proof (list term) -> term.

meta_list_to_proof nil {{eq_refl : nil = @map Z R IZR nil}}.

meta_list_to_proof [P | Tl] {{f_equal2 (@cons R) lp:P lp:R}} :- meta_list_to_proof Tl R.

meta_list_to_proof uvar _ :- coq.error "invalid input meta_list_to_proof called with flexible argument".

pred translate_prf_list list term -> list term, list term.

translate_prf_list nil nil nil.

translate_prf_list [R|Tl] [Z|TlZ] [Prf|PrfT] :-
  translate_prf R Z Prf,
  translate_prf_list Tl TlZ PrfT.

translate_prf (fun N {{nat}} F) (fun N {{nat}} F1)
  T :-
  (pi CN \
    translate_prf {{INR lp:CN}} {{Z.of_nat lp:CN}} {{INR_IZR_INZ lp:CN}} =>
    translate_prf (F CN) (F1 CN) (PF CN)),
    T = (fun N {{nat1}} PF).

translate_prf (fun M {{R}} Bo) (fun M {{Z}} BoZ) Prf :-
  (pi V VZ H\
  (decl V M {{R}} ,
  decl VZ _ {{Z}} ,
  translate_prf V VZ H) ==>
  translate_prf (Bo V) (BoZ VZ) (Pf V VZ H),
  Prf = {{fun (r_test : R) (z : Z) (h : r_test = IZR z) => 
  lp:(Pf r_test z h)}}).

translate_prf (fun M T Bo) (fun M {{ty_ R lp:N}} BoZ) Prf :-
  type_to_nargs T Nint,
  int_to_nat Nint N,
  (pi V VZ H\
  (decl V M T ,
  decl VZ _ {{ty_ Z lp:N}} ,
  translate_prf V VZ H) ==>
  translate_prf (Bo V) (BoZ VZ) (Pf V VZ H),
  Prf = {{fun (r : R) (z : Z) (h : r = IZR z) => lp:(Pf r z h)}})
  % )
  .

translate_prf (fun L {{list R}} F) (fun L {{list Z}} F1)
  PF0 :-
  (pi Cl1 Cl2 Hll \
  (decl Cl1 L {{list (R)}},
    decl Cl2 _ {{list (Z)}},
    decl Hll `IH` {{lp:Cl1 = map IZR lp:Cl1}},
    translate_prf Cl1 Cl2 Hll) =>
    translate_prf (F Cl1) (F1 Cl2) (PF Cl1 Cl2 Hll)),
    PF0 = {{fun (lr : list (R)) (lz : list (Z))
      (h : lr = @map Z R IZR lz :> list R) => lp:(PF lr lz h)}}.

translate_prf (fun L {{list (R -> R)}} F) (fun L {{list (Z -> Z)}} F1)
   PF0 :-
   (pi Cl1 Cl2 Hll L2 \
   (decl Cl1 L {{list (R -> R)}},
    decl Cl2 _ {{list (Z -> Z)}},
    decl Hll `IH` {{P_trans1 lp:Cl1 IZR lp:Cl2}},
     translate_prf Cl1 Cl2 Hll) =>
     translate_prf (F Cl1) (F1 Cl2) (PF Cl1 Cl2 Hll)),
     PF0 = {{fun (lr : list (R->R)) (lz : list (Z->Z))
       (h : P_trans1 lr IZR lz ) => lp:(PF lr lz h)}}.

translate_prf (fun L {{list lp:T}} F) (fun L {{list (ty_ Z lp:N)}} F1)
   PF0 :-
   type_to_nargs T Nint,
   int_to_nat Nint N,

   (pi Cl1 Cl2 Hll L2 \
   (decl Cl1 L {{list (ty_ R lp:N)}},
    decl Cl2 _ {{list (ty_ Z lp:N)}},
    decl Hll `IH` {{P_transN lp:N lp:Cl1 IZR lp:Cl2}},
     translate_prf Cl1 Cl2 Hll) =>
     translate_prf (F Cl1) (F1 Cl2) (PF Cl1 Cl2 Hll)),
     PF0 = {{fun (lr : list (ty_ R lp:N)) (lz : list (ty_ Z lp:N))
       (h : P_transN lp:N lr IZR lz ) => lp:(PF lr lz h)}}.


translate_prf {{nth lp:K lp:L (cst_ R 0%R 0)}} {{nth lp:K lp:Lz (cst_ Z 0%Z 0)}}
  {{private.nth_map (cst_ Z 0%Z 0) (cst_ R 0%R 0) IZR lp:Lz lp:L lp:K eq_refl lp:H}} :-
  translate_prf L Lz H.

translate_prf {{nth lp:K lp:L (cst_ R 0%R 1) lp:A_r}} {{nth lp:K lp:Lz (cst_ Z 0%Z 1) lp:A_z}}
  {{(trf_trans lp:L IZR lp:Lz lp:H) lp:K lp:A_z lp:A_r lp:Pa}} :-
  translate_prf L Lz H,
  translate_prf A_r A_z Pa.

translate_prf (app [{{nth}}, Ty , K , L , {{cst_ R 0%R lp:NNat}} | ArgsR]) 
(app [{{nth}} , {{ty_ Z lp:NNat}}, K , Lz , {{cst_ Z 0%Z lp:NNat}} | ArgsZ]) 
  {{(trf_transN lp:NNat lp:L IZR lp:Lz lp:H) lp:K lp:Az lp:Ar lp:PaL}} :-
  std.do![
  type_to_nargs Ty N,
  int_to_nat N NNat,
  translate_prf L Lz H,
  translate_prf_list ArgsR ArgsZ Pa,
  meta_list_to_list ArgsZ Az,
  meta_list_to_list ArgsR Ar,
  meta_list_to_proof Pa PaL
  ].


translate_prf {{@nil R}} {{@nil Z}} {{eq_refl : nil = @map Z R IZR nil}}:- !.

translate_prf {{@nil (R->R)}} {{@nil (Z->Z)}} {{P_trans1_nil}} :- !.

translate_prf {{@nil lp:T}} {{@nil (ty_ Z lp:NNat)}} {{P_transN_nil lp:NNat}} :-
type_to_nargs T N,
int_to_nat N NNat.

translate_prf {{@cons R lp:A lp:L}} {{cons lp:A1 lp:L1}}
  {{f_equal2 (@cons (ty_ R 0)) lp:Pfa lp:Pfl}}:-
  !, std.do! [
    translate_prf A A1 Pfa,
    translate_prf L L1 Pfl
  ].

translate_prf {{@cons (R->R) lp:A lp:L}} {{cons lp:A1 lp:L1}}
  {{P_trans1_cons lp:A lp:A1 lp:L lp:L1 (proj2 (fun1_trf lp:A lp:A1 IZR) lp:Pfa) lp:Pfl}}:-
  !, std.do! [
    translate_prf A A1 Pfa,
    translate_prf L L1 Pfl
  ].

translate_prf {{(@cons lp:T) lp:A lp:L}} {{@cons (ty_ Z lp:NNat)lp:A1 lp:L1}}
  {{P_transN_cons lp:NNat lp:A lp:A1 lp:L lp:L1 
  (proj2 (@funN_trf lp:NNat lp:A lp:A1 IZR) lp:P) lp:Pfl}}:-
  !, std.do! [
    type_to_nargs T N,
    int_to_nat N NNat,
    translate_prf A A1 Pfa,
    translate_prf L L1 Pfl,
    gen N A A1 Pfa P
  ].

translate_prf {{IZR lp:A}} {{lp:A}} {{eq_refl: IZR lp:A = IZR lp:A}}.

translate_prf (app [F, {{Rabs lp:A}}]) (app [F1, A1])
  {{lp:PFF1 lp:A lp:A1 lp:PRFA}} :-
  std.do![
    nat_thm_table F F1 PFF1,
    translate_prf A A1 PRFA
  ].

translate_prf {{lp:F (IZR (Zpos lp:P))}}
  {{lp:Fz (Zpos lp:P)}}
  {{private.cancel_Rabs_pos lp:F lp:Fz lp:Prf lp:P}} :-
  nat_thm_table F Fz Prf.

translate_prf {{lp:F (IZR (Zpos lp:P)) lp:R}}
  {{lp:Fz (Zpos lp:P) lp:Z}}
  {{private.cancel_Rabs_pos2 lp:F lp:Fz lp:Prf lp:P lp:R lp:Z lp:PrfRZ}} :-
  translate_prf R Z PrfRZ,
  nat_thm_table F Fz Prf.

translate_prf (app [F, A]) (app [F1, A1])
  {{private.IZR_map1 lp:F lp:F1 lp:PFF1 lp:A lp:A1 lp:PFRA}} :-
  std.do! [
  thm_table F F1 PFF1,
  translate_prf A A1 PFRA
  ].

type marker int -> term.

translate_prf (app [F, A]) (app [F1, A1])
  {{private.Rnat_Rabs lp:PFF1 lp:A lp:A1 lp:Nat_prf lp:PRFA}} :-
  std.do![
    nat_thm_table F F1 PFF1,
    translate_prf A A1 PRFA,
    rnat_prf A A1 PRFA F Nat_prf
  ].



translate_prf (app [F, A, B]) (app [F1, A1, B1])
  {{private.IZR_map2 lp:F lp:F1 lp:PFF1 lp:A lp:B lp:A1 lp:B1 lp:PFRA lp:PFRB}}
  :-
  std.do! [
  thm_table F F1 PFF1,
  translate_prf A A1 PFRA,
  translate_prf B B1 PFRB
  ].

translate_prf (app [F, A, B, C]) (app [F1, A1, B1, C1])
  {{private.IZR_map3 lp:F lp:F1 lp:PFF1 lp:A lp:B lp:C lp:A1 lp:B1 lp:C1 lp:PFRA lp:PFRB lp:PFRC}}
  :-
  std.do! [
  thm_table F F1 PFF1,
  translate_prf A A1 PFRA,
  translate_prf B B1 PFRB,
  translate_prf C C1 PFRC
  ].

translate_prf (app [F, A, B, C, D]) (app [F1, A1, B1, C1, D1])
  {{private.IZR_map4 lp:F lp:F1 lp:PFF1 lp:A lp:B lp:C lp:D lp:A1 lp:B1 lp:C1 lp:D1 lp:PFRA lp:PFRB lp:PFRC lp:PRFD}}
  :-
  std.do! [
  thm_table F F1 PFF1,
  translate_prf A A1 PFRA,
  translate_prf B B1 PFRB,
  translate_prf C C1 PFRC,
  translate_prf D D1 PRFD,
  ].

translate_prf (app [F, A | Args]) (app [F1, A1 | Args1])
  {{private.Rnat_RabsN lp:PFF1 lp:A lp:A1 lp:Nat_prf lp:PrfA lp:LArgs lp:LArgs1 lp:LPrf}}
  :-
  std.do! [
  nat_thm_table F F1 PFF1,
  translate_prf A A1 PrfA,
  rnat_prf A A1 PrfA F Nat_prf,
  meta_list_to_list Args LArgs,
  translate_prf_list Args Args1 PRFArgs,
  meta_list_to_list Args1 LArgs1,
  meta_list_to_proof PRFArgs LPrf,
  ].

func prf_stmt term, term, term -> term.

prf_stmt {{Z->Z}} Ft FG {{forall (n : R) z, n = IZR z ->
lp:FG (Rabs n) = IZR (lp:Ft z)}} :- !.

prf_stmt {{Z->Z->Z}} Ft FG
  {{forall (r : R) (z : Z), r = IZR z ->  forall (a : R) (b : Z) , a = IZR b ->
  (lp:FG (Rabs r)) a = IZR ((lp:Ft z) b) }} :- !.

prf_stmt {{Z -> ty_ Z (lp:N)}} Ft FG
  {{forall (r : R) (z : Z), r = IZR z -> forall (lr : list R) (lz : list Z), lr = List.map IZR lz ->
  @MappR lp:N (lp:FG (Rabs r)) lr = IZR (@MappZ lp:N (lp:Ft z) lz)}} :- !
.

func main_translate_prf1 term, term -> term,  term, term.
pred translate_list_prf list term -> list term, list term.

main_translate_prf1
  L ((fun _N {{nat}} c\ (fun _N1 Ty _)) as F) L1 F1
  {{fun N : R => fun z : Z =>

     (nat_rect_list 
        lp:L1 lp:L lp:F1 lp:F
        (Z.abs_nat z)
        (* (fun (i : nat) (x : Z) =>
           match i return nth i lp:L (cst_ R 0%R 1) (IZR x) = IZR (nth i lp:L1 (cst_ Z 0%Z 1) x) with
            | 0 =>  (lp:LP 0%nat x)
            | S p => (nth_overflow_1 (nth 0 lp:L (cst_ R 0%R 1)) (nth 0 lp:L1 (cst_ Z 0%Z 1)) p x)
            end) *)
            lp:LP
        lp:FPRF)}} :-
      Ty = {{list (R -> R)}},
      std.do! [
      translate_prf L L1 LP,
      translate_prf F F1 FPRF
    ],!.

main_translate_prf1
  L ((fun _N {{nat}} c\ (fun _N1 Ty _)) as F) L1 F1
  {{fun N : R => fun z : Z =>
     private.nth_map 0%Z 0 IZR _ _ 0 eq_refl
     (private.nat_rect_list_IZR lp:L1 lp:L lp:F1 lp:F
       (Z.abs_nat z) eq_refl lp:FPRF)}} :-
    std.do! [
      Ty = {{list (R)}},
      translate_prf L L1 _,
      translate_prf F F1 FPRF
    ],!.

main_translate_prf1
  L ((fun _N {{nat}} c\ (fun _N1 {{list lp:Ty}} _)) as F) L1 F1
  {{fun _ : R => fun z : Z =>
     (nat_rect_list_N lp:N
        lp:L1 lp:L lp:F1 lp:F
        (Z.abs_nat z) lp:LP

        lp:FPRF)}} 
      :-
      type_to_nargs Ty Nint,
      int_to_nat Nint N,
      std.do! [
      translate_prf L L1 LP,
      translate_prf F F1 FPRF
    ],!.




main_translate_prf {{fun (n : R) =>
nth 0 (Rnat_rec lp:L lp:Frstep0 n) (cst_ R 0%R 0)}} F Prf1 :-
  !,
  Frstep0 = (fun _ {{R}} Frstep),
  Fnstep = (fun _ {{nat}} c \ (Frstep {{INR lp:c}})),
  main_translate_prf1 L Fnstep Lz Fz Prf,
  F = {{fun (x : Z) =>
         nth 0 (nat_rect (fun _ => list Z) lp:Lz
           lp:Fz (Z.abs_nat x)) 0%Z}},
  std.assert-ok! (coq.typecheck F {{Z->Z}})
    "failed to typecheck mirror function",
  Prf1 =
    {{fun (n : R) (z : Z) (nzq : n = IZR z) =>
       eq_ind_r
         (fun x : nat =>
           nth 0 (nat_rect _ lp:L lp:Fnstep x) 0 =
           IZR (nth 0 (nat_rect _ lp:Lz lp:Fz (Z.abs_nat z)) 0%Z))
        (lp:Prf n z)
          (private.IRN_Z_abs_nat _ _ nzq)}}.

main_translate_prf
  {{fun (r : R) =>
      nth 0 (Rnat_rec lp:L lp:Frstep0 r) (cst_ R 0%R 1)}}
  F Prf1 :- !,
  Frstep0 = (fun _ {{R}} Frstep),
  Fnstep = (fun _ {{nat}} c \ (Frstep {{INR lp:c}})),
  main_translate_prf1 L Fnstep Lz Fz Prf,
  F = {{fun (x : Z) =>
         nth 0 (nat_rect (fun _ => list (Z->Z)) lp:Lz
           lp:Fz (Z.abs_nat x)) (cst_ Z 0%Z 1)}},
  std.assert-ok! (coq.typecheck F {{Z->Z->Z}})
    "failed to typecheck mirror function",
  Prf1 =
    {{
      fun (r : R) (z : Z) (nzq : r = IZR z) =>
      private.IZR_map1' (
       (eq_ind_r
         (fun x : nat =>
          P_trans1
          (nat_rect _ lp:L lp:Fnstep x) IZR
          (nat_rect _ lp:Lz lp:Fz (Z.abs_nat z))
          )
        (lp:Prf r z)
          (private.IRN_Z_abs_nat _ _ nzq)) 0%nat)
          }}.

main_translate_prf
  ({{fun (r : R) =>
      nth 0 (Rnat_rec lp:L lp:Frstep0 r) (cst_ R 0%R lp:N) }})
  F Prf1 :-
  !,
  Frstep0 = (fun _ {{R}} Frstep),
  Fnstep = (fun _ {{nat}} c \ (Frstep {{INR lp:c}})),
  main_translate_prf1 L Fnstep Lz Fz Prf,
  F = {{fun (x : Z) =>
         nth 0 (nat_rect (fun _ => list (ty_ Z lp:N)) lp:Lz
           lp:Fz (Z.abs_nat x)) (cst_ Z 0%Z lp:N)}},
  std.assert-ok! (coq.typecheck F {{ty_ Z (S lp:N)}})
    "failed to typecheck mirror function",
  Prf1 =
    {{
      (fun (r : R) (z : Z) (nzq : r = IZR z) =>
      private.IZR_mapN (
       (eq_ind_r
         (fun x : nat =>
          P_transN lp:N
          (nat_rect (fun _ : nat => list (ty_ R lp:N)) lp:L lp:Fnstep x) IZR
          (nat_rect (fun _ : nat => list (ty_ Z lp:N)) lp:Lz lp:Fz (Z.abs_nat z))
          )
        (lp:Prf r z)
          (private.IRN_Z_abs_nat _ _ nzq)) 0%nat))
          
          }}.

main [str F] :-
std.do! [
  std.assert! (coq.locate F (const FGR))
    "the argument is not a known constant",
  std.assert! (coq.env.const-body FGR (some Bo))
    "the constant does not have a value",
  std.assert! (main_translate_prf Bo BoZ Prf)
    "translation failed. Possible causes are:\n
1/ the function was not generated by the command Recursive\n
2/ some function without computational correspondence may be used\n
   (in that case, use add_computation to provide missing information)\n
3/ you are using a function that is defined only on natural numbers\n
   but you are not encapsulating its argument in a Rabs call",
  std.assert-ok! (coq.typecheck BoZ Ty)
     "Anomaly: generating an ill-typed term",
  F_mirror is F ^ "_Z_mirror",
  coq.env.add-const F_mirror BoZ Ty @transparent! C,
  Fterm = global (const C),
  prf_stmt Ty Fterm (global (const FGR)) Stmt,
  std.assert-ok! (coq.typecheck Prf Stmt)
          "Anomaly: generating an incorrect proof",
  F_prf is F ^ "_Z_prf",
  coq.env.add-const F_prf Prf Stmt @opaque! Cprf,
  coq.elpi.accumulate _ "R_compute.db"
    (clause _ _ (nat_thm_table (global (const FGR))
                   (global (const C))
                   (global (const Cprf))))
].

main L :-
  coq.error "Usage: Elpi mirror_recursive_definition Name.\n instead received: " L.